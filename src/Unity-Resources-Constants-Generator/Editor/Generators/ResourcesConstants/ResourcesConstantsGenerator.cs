using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Editor.Generators
{
    public static class EditorPrefsConstants
    {
        public const string OutputPath = "ResourcesConstants_OutputPath";
        public const string FileExtensions = "ResourcesConstants_FileExtensions";
        public const string ClassName = "ResourcesConstants_ClassName";
        public const string IncludeSubfolders = "ResourcesConstants_IncludeSubfolders";
        public const string AutoGenerateOnChange = "ResourcesConstants_AutoGenerate";
        public const string OpenWindowOnFileAdd = "ResourcesConstants_OpenWindowOnFileAdd";
    }

    public static class ResourcesConstantsGenerator
    {
        public static class DefaultValues
        {
            public const string OutputPath = "Assets/Generated/ResourcesKeys.cs";
            public const string FileExtensions = "*.prefab,*.asset,*.png,*.jpg,*.mat,*.fbx";
            public const string ClassName = "ResourcesConstants";
            public const bool IncludeSubfolders = true;
        }

        private const string AutoGeneratedComment = "// This file is auto-generated. Do not modify manually.";
        private const string MenuItemPath = "Tools/Resources Constants Generator/Generate Resources Keys";
        private const int MenuItemPriority = 1;

        [MenuItem(itemName: MenuItemPath, priority = MenuItemPriority)]
        public static void Generate()
        {
            var outputPath = EditorPrefs.GetString(EditorPrefsConstants.OutputPath, DefaultValues.OutputPath);
            var fileExtensions =
                EditorPrefs.GetString(EditorPrefsConstants.FileExtensions, DefaultValues.FileExtensions);
            var className = EditorPrefs.GetString(EditorPrefsConstants.ClassName, DefaultValues.ClassName);
            var includeSubfolders =
                EditorPrefs.GetBool(EditorPrefsConstants.IncludeSubfolders, DefaultValues.IncludeSubfolders);

            var extensions = fileExtensions.Split(',')
                .Select(ext => ext.Trim())
                .Where(ext => !string.IsNullOrEmpty(ext))
                .ToArray();

            if (string.IsNullOrWhiteSpace(className))
            {
                Debug.LogWarning($"Class name is empty in settings. Using default name: {DefaultValues.ClassName}.");
                className = DefaultValues.ClassName;
            }

            Generate(outputPath, extensions, includeSubfolders, className);
        }

        public static void Generate(string outputPath, string[] fileExtensions, bool includeSubfolders,
            string className)
        {
            var allResourceFolders = Directory
                .GetDirectories(Application.dataPath, "Resources", SearchOption.AllDirectories)
                .Select(dir => Path.GetFullPath(dir))
                .ToList();

            if (allResourceFolders.Count == 0)
            {
                Debug.LogWarning("No Resources folders found in the project.");
                return;
            }

            var keys = new HashSet<(string path, string formattedKey, string extension)>();

            foreach (var resourceFolder in allResourceFolders)
            {
                var searchOption = includeSubfolders ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;

                var resourceFiles = new List<string>();
                foreach (var ext in fileExtensions)
                {
                    resourceFiles.AddRange(Directory.GetFiles(resourceFolder, ext, searchOption));
                }

                var filteredFiles = resourceFiles
                    .Where(file => !file.EndsWith(".meta"))
                    .Select(file =>
                    {
                        var fullRelativePath = Path.GetRelativePath(Application.dataPath, file).Replace("\\", "/");
                        var relativePath = fullRelativePath.Replace("Assets/", "");
                        var pathWithoutExtension = Path.ChangeExtension(relativePath, null);
                        var fileName = Path.GetFileNameWithoutExtension(file);
                        var fileExtension = Path.GetExtension(file).TrimStart('.').ToLower();
                        var formattedKey = FormatKey(fileName);
                        Debug.Log($"Processing file: {relativePath}, Key: {formattedKey}, Extension: {fileExtension}");
                        return (path: pathWithoutExtension, formattedKey, extension: fileExtension);
                    })
                    .ToList();

                foreach (var key in filteredFiles)
                {
                    keys.Add(key);
                }
            }

            if (keys.Count == 0)
            {
                Debug.LogWarning("No valid resource files found in any Resources folders.");
                return;
            }

            var classContent = GenerateClass(keys, className);

            var directory = Path.GetDirectoryName(outputPath);
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory ?? throw new InvalidOperationException("Wrong path directory"));
            }

            File.WriteAllText(outputPath, classContent);
            AssetDatabase.Refresh();

            Debug.Log(
                $"ResourcesKeys.cs was generated at {outputPath} with {keys.Count} keys from {allResourceFolders.Count} Resources folders");
        }

        private static string GenerateClass(IEnumerable<(string path, string formattedKey, string extension)> keys,
            string className)
        {
            var root = new ClassNode(className);

            foreach (var (path, formattedKey, extension) in keys)
            {
                var segments = path.Split('/');
                var resourcesIndex = Array.IndexOf(segments, "Resources");

                if (resourcesIndex == -1 || resourcesIndex == segments.Length - 1)
                {
                    Debug.LogWarning($"Path {path} does not contain a valid Resources segment.");
                    continue;
                }

                var beforeResources = segments.Take(resourcesIndex);
                var afterResources = segments.Skip(resourcesIndex + 1).ToArray();
                var fileName = Path.GetFileName(path);
                var keyName = $"{extension}_{formattedKey}";

                var currentNode = root;
                foreach (var part in beforeResources)
                {
                    currentNode = currentNode.GetOrAddChild(FormatKey(part));
                }

                currentNode = currentNode.GetOrAddChild("Resources");

                for (var i = 0; i < afterResources.Length - 1; i++)
                {
                    currentNode = currentNode.GetOrAddChild(FormatKey(afterResources[i]));
                }

                var fileKey = FormatKey(Path.GetFileNameWithoutExtension(fileName));
                var constKey = $"{extension}_{fileKey}";
                var constValue = string.Join("/", afterResources);

                var finalConstKey = constKey;
                var counter = 1;
                while (currentNode.constants.Any(c => c.Contains($"const string {finalConstKey}")))
                {
                    finalConstKey = $"{constKey}_{counter++}";
                }

                currentNode.constants.Add($"    public const string {finalConstKey} = \"{constValue}\";");
            }

            return $"{AutoGeneratedComment}\n\n{root}";
        }

        private static string FormatKey(string key)
        {
            if (char.IsDigit(key[0]))
            {
                key = $"file_{key}";
            }

            return key.Replace(" ", "_")
                .Replace("@",  "__")
                .Replace("-",  "_")
                .Replace(".",  "_")
                .Replace("/",  "_")
                .Replace("\\", "_")
                .Replace("[",  "_")
                .Replace("]",  "_")
                .Replace("&",  "_And_")
                .Replace(":",  "_");
        }

        private class ClassNode
        {
            public string name { get; }
            public List<string> constants { get; } = new();
            public Dictionary<string, ClassNode> children { get; } = new();

            public ClassNode(string name)
            {
                this.name = name;
            }

            public ClassNode GetOrAddChild(string name)
            {
                if (!children.TryGetValue(name, out var child))
                {
                    child = new ClassNode(name);
                    children[name] = child;
                }

                return child;
            }

            public override string ToString()
            {
                var lines = new List<string>
                {
                    $"public static class {name}",
                    "{"
                };

                lines.AddRange(constants);

                foreach (var child in children.Values.OrderBy(c => c.name))
                {
                    if (constants.Count > 0 && child == children.Values.First())
                    {
                        lines.Add("");
                    }

                    lines.AddRange(child.ToString().Split('\n').Select(l => "    " + l));
                }

                lines.Add("}");
                return string.Join("\n", lines);
            }
        }
    }
}