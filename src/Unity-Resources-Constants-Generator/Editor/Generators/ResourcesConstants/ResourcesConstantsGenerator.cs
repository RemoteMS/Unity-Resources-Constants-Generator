using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Editor.Generators
{
    public static class EditorPrefsConstants
    {
        public const string OutputPath = "ResourcesConstants_OutputPath";
        public const string FileExtensions = "ResourcesConstants_FileExtensions";
        public const string ClassName = "ResourcesConstants_ClassName";
        public const string IncludeSubfolders = "ResourcesConstants_IncludeSubfolders";
        public const string AutoGenerateOnChange = "ResourcesConstants_AutoGenerate";
        public const string OpenWindowOnFileAdd = "ResourcesConstants_OpenWindowOnFileAdd";
    }

    public static class ResourcesConstantsGenerator
    {
        public static class DefaultValues
        {
            public const string OutputPath = "Assets/Generated/ResourcesKeys.cs";
            public const string FileExtensions = "*.prefab,*.asset,*.png,*.jpg,*.mat,*.fbx";
            public const string ClassName = "ResourcesConstants";
            public const bool IncludeSubfolders = true;
        }

        private const string AutoGeneratedComment = "// This file is auto-generated. Do not modify manually.";

        private static void GenerateMain(string outputPath, string[] extensions, bool includeSubfolders,
            string className)
        {
            // Check if the class name is set
            if (string.IsNullOrWhiteSpace(className))
            {
                Debug.LogWarning($"Class name is empty in settings. Using default name: {DefaultValues.ClassName}.");
                className = DefaultValues.ClassName;
            }

            // Get directory and file name from outputPath
            var directory = Path.GetDirectoryName(outputPath);
            var fileName = Path.GetFileName(outputPath); // Используем имя файла из OutputPath

            // Find all Resources folders in the project
            var allResourceFolders = Directory
                .GetDirectories(Application.dataPath, "Resources", SearchOption.AllDirectories)
                .Select(dir => Path.GetFullPath(dir))
                .ToList();

            if (allResourceFolders.Count == 0)
            {
                Debug.LogWarning("No Resources folders found in the project.");
                return;
            }

            // Collecting unique keys
            var keys = new HashSet<(string path, string formattedKey)>();

            foreach (var resourceFolder in allResourceFolders)
            {
                var searchOption = includeSubfolders ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;

                foreach (var ext in extensions)
                {
                    var files = Directory.GetFiles(resourceFolder, ext, searchOption)
                        .Where(file => !file.EndsWith(".meta"))
                        .Select(file =>
                        {
                            var relativePath = Path.GetRelativePath(resourceFolder, file);
                            var pathWithoutExtension = Path.ChangeExtension(relativePath, null);
                            var formattedKey = FormatKey(Path.GetFileName(pathWithoutExtension));
                            return (path: pathWithoutExtension, formattedKey);
                        })
                        .ToList();

                    foreach (var key in files)
                    {
                        keys.Add(key);
                    }
                }
            }

            if (keys.Count == 0)
            {
                Debug.LogWarning("No valid resource files found in any Resources folders.");
                return;
            }

            // Generate class contents
            var classContent = GenerateClass(keys, className);

            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory ?? throw new InvalidOperationException("Wrong path directory"));
            }

            // Add AutoGeneratedComment and class contents to the file
            var finalContent = new StringBuilder();
            finalContent.AppendLine(AutoGeneratedComment);
            finalContent.AppendLine();
            finalContent.Append(classContent);

            File.WriteAllText(outputPath, finalContent.ToString());
            AssetDatabase.Refresh();

            Debug.Log(
                $"{fileName} was generated at {outputPath} with {keys.Count} keys from {allResourceFolders.Count} Resources folders");
        }

        public static void Generate(string outputPath, string fileExtensions, bool includeSubfolders, string className)
        {
            var extensions = fileExtensions.Split(',')
                .Select(ext => ext.Trim())
                .Where(ext => !string.IsNullOrEmpty(ext))
                .ToArray();

            GenerateMain(outputPath, extensions, includeSubfolders, className);
        }

        [MenuItem(itemName: "Tools/Resources Constants Generator/Generate Resources Keys", priority = 1)]
        public static void Generate()
        {
            // Getting settings from EditorPrefs with default values
            var outputPath = EditorPrefs.GetString(EditorPrefsConstants.OutputPath, DefaultValues.OutputPath);
            var fileExtensions =
                EditorPrefs.GetString(EditorPrefsConstants.FileExtensions, DefaultValues.FileExtensions);
            var className = EditorPrefs.GetString(EditorPrefsConstants.ClassName, DefaultValues.ClassName);
            var includeSubfolders =
                EditorPrefs.GetBool(EditorPrefsConstants.IncludeSubfolders, DefaultValues.IncludeSubfolders);

            // Separating file extensions
            var extensions = fileExtensions.Split(',')
                .Select(ext => ext.Trim())
                .Where(ext => !string.IsNullOrEmpty(ext))
                .ToArray();

            GenerateMain(outputPath, extensions, includeSubfolders, className);
        }

        private static string GenerateClass(IEnumerable<(string path, string formattedKey)> keys, string className)
        {
            var root = new ClassNode(className);

            foreach (var (path, formattedKey) in keys.OrderBy(k => k.path))
            {
                var parts = path.Split('/', '\\');
                var currentNode = root;

                for (var i = 0; i < parts.Length - 1; i++)
                {
                    var folderName = FormatKey(parts[i]);
                    currentNode = currentNode.GetOrAddChild(folderName);
                }

                var keyValue = path.Replace("\\", "/");
                currentNode.constants.Add($"    public const string F_{formattedKey} = \"{keyValue}\";");
            }

            return root.ToString();
        }

        private static string FormatKey(string key)
        {
            return key.Replace(" ", "_")
                .Replace("@",  "__")
                .Replace("-",  "_")
                .Replace(".",  "_")
                .Replace("/",  "_")
                .Replace("\\", "_")
                .Replace("[",  "_")
                .Replace("]",  "_")
                .Replace("&",  "_And_")
                .Replace(":",  "_")
                .ToUpperInvariant();
        }

        private class ClassNode
        {
            public string name { get; }
            public List<string> constants { get; } = new();
            public Dictionary<string, ClassNode> children { get; } = new();

            public ClassNode(string name)
            {
                this.name = name;
            }

            public ClassNode GetOrAddChild(string name)
            {
                if (!children.TryGetValue(name, out var child))
                {
                    child = new ClassNode(name);
                    children[name] = child;
                }

                return child;
            }

            public override string ToString()
            {
                var lines = new List<string>();
                lines.Add($"public static class {name}");
                lines.Add("{");

                foreach (var constant in constants)
                {
                    lines.Add(constant);
                }

                foreach (var child in children.Values.OrderBy(c => c.name))
                {
                    if (constants.Count > 0 && child == children.Values.First())
                    {
                        lines.Add("");
                    }

                    lines.AddRange(child.ToString().Split('\n').Select(l => "    " + l));
                }

                lines.Add("}");
                return string.Join("\n", lines);
            }
        }
    }
}